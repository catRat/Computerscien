算法一种非正式定义如下：算法是一种逐步解决问题或完成任务的方法。

按照这种定义，算法完全独立于计算机体系。更特别的是，还应该记住算法接受一组输入数据，同时产生一组输出数据。

下面用一个例子来对这种简单的定义进行分析。我们要生成从一组正整数中找到最大整数的一个算法。这个算法应该能从一组任意整数中找出其最大值。这个算法必须具有通用性并与整数的个数无关。

很明显，要完成从许多整数中找到最大值的这个任务不可可能只要一步完成。算法必须一个个地测试每一个整数。

要解决这个问题，可以用一种直接的方法。先用一组少量的整数，然后将这种解决方法扩大到任意多的整数。其实对5个整数所采取的解决方法的原理和约束条件与对1 000个或1 000 000个整数采取的是一样的。可以假设，即使是5个整数的例子，算法也必须一个接一个地处理那些整数。看到第一个整数，并不知道剩下的整数的值。等处理完第一个整数，算法才开始处理第二个整数，依次进行。

我们称这个算法为求最大值算法。每个算法都有自己不同于其他算法的名字。这个算法接收一组5个整数作为输入，然后输出其中的最大值。

细化。为了使算法能在所有的程序中应用，还需要进行细化。现在有两个问题，首先，第一步中的动作与其他步骤中不一样。其次第二步到第五步中的程序描述语言不通。我们只要很简单地改进一下算法就可以解决以上两个问题。把第二步到第五步的程序段都写成“如果当前整数大于Largest，那么当前整数就称为Largest”。第一步不通于其他步是因为那时Largest还没有初始化。如果开始就把Largest初始化为负无穷，那么第一步就可写成和其他步一样，所以。增加一个新的步骤，可称为第0步，也就是表明它要在处理任何其他整数之前完成。

可以把这个算法泛化吗？假设要从$n$个正整数中找到最大值，$n$的值可能是1 000或1 000 000，或者更多。当然，可以按照图所示那样重复每一步。

计算机专家为结构化程序或算法定义了三种结构。这种想法认为程序必定是由顺序、判断（选择）和循环这三种结构组成。已经证实其他结构都是不必要的。仅仅使用这三种结构就可以是程序或算法容易理解、调试或修改。

第一种结构称为顺序结构。算法都是指令序列。它可以是一简单指令或其他两种结构之一。

有些问题只用简单的指令序列是不能够解决的。有时候需要检测一个条件是否满足。假如测试的结果为真，则可以继续顺序往下执行指令；假如结果为假，程序将从另外一个顺序结构的指令继续执行。这就是所谓的判断（选择）结构。

有些问题中，相同指令序列需要重复。可以用重复或循环结构来解决这个问题。

到目前为止，我们已经使用图来表示算法的基本概念。在最近几十年中，还出现了其他几种用来表示算法的工具。这里讲介绍UML和伪代码这两种工具。

统一建模语言（UML）是算法的图形表示法。它使用“大图”的形式掩盖了算法的所有细节，它只显示算法从开始到结束的整个流程。

伪代码是算法的一种类似英语的表示法。现在还没有伪代码的标准。有些人使用得过细，有些人则使用得过粗。有些人用一种很像英语的代码，有些则用和Pascal编程语言相似的语法。

既然我们讨论了算法的概念并且给出了它的表示，下面给出算法更为正式的定义。

算法是一组明确步骤的有序集合，它产生结果并在有限时间内终止。

算法必须是一组定义良好的有序的指令集合。

算法的每一步都必须有清晰、明白的定义。如某一步是将两整数相加，那么必须定义相加的两个整数和加法符号，相同的符号不能再某处用作加法符号，而在其他地方用作乘法符号。

算法必须产生结果，否则该算法就没有意义。结果可以是返回给调用算法的数据或其他效果（如打印）。

算法必须能够终止（停机）。如果不能，说明不是算法。

有一些算法在计算机科学中应用的非常普遍，我们称之为“基本”算法。这里讲讨论一些最常用的算法。讨论只是概括性的，具体的实现则取决于采用何种语言。

计算机科学中经常用到的一种算法是求和。你可以容易地实现两个或三个整数的相加，但是怎样才能实现一系列整数相加呢？答案很简单：在循环中使用加法操作。

求和算法可以分为三个逻辑部分：

1）将和（sum）初始化。

2）循环，在每次迭代总将一个新数加到和（sum）上。

3）推出循环后返回结果。

另一个常用算法是求出一系列整数的乘积。方法也很简单：在循环中使用乘法操作。乘法算法有三个逻辑部分：

1）将乘积（product）初始化。

2）循环，在每次迭代中将一个新数与乘积相乘。

3）推出循环后返回结果。

在本章开头讨论了求一组整数中最大值的算法。它的思想是通过一个判断结构求到两个数中的较大值。如果是把这个结构放在循环中，就可以求出一组数中的最大值。

求一组整数中的最小值和上面的方法相似，只有两个小小的不同。

计算机科学总的一个最普遍应用的是排序，即根据数据的值对它们进行排列。人们的周围充满了数据，如果这些数据都是无序的，可能会花很多时间去查找一条简单信息。

本节将介绍三种排序算法：选择排序、冒泡排序、插入排序。这三种方法是当今计算机科学中使用的快速排序的基础。

在选择排序中，数字列表可分为两个字列表，它们通过假想的一堵墙分开。求未排序子列表中最小的元素并把它和未排序子列表中第一个元素进行交换，进过每次选择和交换，两个子列表中假想的这堵墙向前移动一个元素，这样 每次排序列表中将增加一个元素而未排序列表中将减少一个元素，每次把一个元素从未排序列表一道已排序列表就完成了一轮排序。一个还有$n$个元素的数字列表需要$n-1$轮排序来完成数据的重新排序。

根据在8.2节描述的三种编程结构，可以为每一个可解的问题创建算法。结构化编程的原则要求将算法分成几个单元，称为子算法。每个子算法依次又分为更小的子算法。

使用子算法至少有两个优点：

程序更容易理解。

子算法可在主算法中不同地方调用，而无需重写。

程序员使用的另一个编程工具就是结构图。结构图是一种高级设计工具，它显示了算法和子算法之间的关系。它一般在设计阶段使用，而不是在编程阶段。

通常，有两种途径用于编写解决问题的算法。一种使用迭代，另一种使用递归。递归是算法的自我调用过程。

学习一个简单的例子，考虑一个阶乘的计算。阶乘的因子是从1到该数的整数。迭代的定义如图所示。如果算法的定义不涉及算法本身，则算法是迭代的。

每一个算法出现在它本身定义中，该算法就是递归定义的。
