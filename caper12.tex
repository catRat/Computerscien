在这一章中，我们讨论抽象数据结构，这是一种比我们在第11章所讨论的数据结构处于更高抽象层的数据类型。ADT使用数据结构来实现。在本章的开始首先对抽象数据类型做一个简短的背景介绍，然后给出定义并提出模型。接着讨论各种不同的抽象数据类型，例如，栈、列队、广义线性表、树、二叉树和图。

使用计算机进行问题求解意味着处理数据。为了处理数据，我们需要定义数据类型和在数据上进行的操作。例如，要求一个列表中的数字之和，我们应该选择数字的类型和定义运算。数据类型的定义和应用于数据的操作定义是抽象数据类型（ADT）背后的一部分概念，隐藏数据上的操作是如何进行的。换言之，ADT的用户只需要知道对主句类型可用的一组操作，而不需要知道他们是如何应用的。

许多编程语言已经定义了一些简单的抽象数据累心工作位语言的整数部分。例如，C语言定义了称为整数的简单抽象数据类型。这种类型的抽象数据类型是带有预先定义范围的整数。C还定义了可以再这种数据类型上应用的几种操作。C显示地定义了整数上的这些操作和我们期望的结果。写C程序来进行两个整数相加，程序员应该知道整数的抽象数据类型和可以应用于该抽象数据类型的操作。

但是，程序员不需知道这些操作是如何实现的。例如，程序员使用表达式$z\leftarrow x+y$，希望$x$的值被加到$y$的值上。结果被命名为$z$。程序员不需要知道加法是如何进行的。在前一章我们学到计算机是如何执行加法运算的：把两个整数以补的格式存储在内存地址中，把它们装进CPU的寄存器中，进行二进制相加，把结果回存到另一个内存地址中。但是，程序员不必知道这些。C语言中的整数就是一个带有预定义操作的简单抽象数据类型。程序员不必关注操作是如何进行的。

几种简单的抽象数据类型已经被实现，在大多数语言中它们对用户是可用的。但是许多有用的复杂抽象数据类型却没有实现。就像我们在这一章中将要看到的，我们需要表抽象数据类型、栈抽象数据类型、列队抽象数据类型等。要提高效率，应该连理这些朝向数据类型，将他们存储在计算机库中，以便使用。例如，表的使用者只需直达该表上有哪些可用的操作，而不需知道这些操作是如何进行的。

因此，对于一个ADT，用户不用关系任务是如何完成的，而是关系能做什么。换言之，ADT包含了一组允许程序使用的操作的定义，而这些操作的实现是隐藏的。这种不需详细地说明实现过程的泛化操作称为抽象。我们抽取了过程的本质，而隐藏了实现的细节。

让我们正式地定义抽象数据类型。抽象数据类型就是与对该数据类型有意义的操作封装在一起的数据类型。然后，用它封装数据和操作并对用户隐藏。

抽象数据类型的模型如图。

计算机语言不提供抽象数据类型包。要使用抽象数据类型，首先要实现它们，把它们存储在库中。本章主要介绍一些常见的抽象数据类型以及应用。但是，我们也为对此有兴趣的读者提供了每个抽象数据类型实现的简单讨论。我们把实现的伪码算法作为挑战练习。

栈是一种限制线性列表，该类列表的添加和删除操作只能在一段实现，称为“栈顶”。如果掺入一系列数据到栈中，然后移走它们，那么数据的顺序将被倒转。数据掺入是的顺序为5，10，15，20，移走后顺序就变成20，15，10，5。这种倒转的属性也正是栈被称为后进先出（LIFO）数据结构的原因。

尽管栈有很多操作，但基本操作有4种：建栈、入栈、出栈和空。

建栈操作常见一个空栈，可是如下：
\begin{verbatim}
push(stackName,dataItem)
\end{verbatim}
stackName是要创建栈的名字。这个操作返回一个空栈。

入栈操作在栈顶添加新的元素，格式如下：
\begin{verbatim}
push(stackName,dataitem)
\end{verbatim}
stackName是栈的名字，dataItem是要插在栈顶的数据。入栈后，新的元素称为栈顶元素。这个操作返回一个dataItem插在顶端的新栈。

出栈操作将栈顶元素移走
\begin{verbatim}
pop(stackName,dataItem)
\end{verbatim}
